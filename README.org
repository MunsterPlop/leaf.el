#+author: conao
#+date: <2018-10-25 Thu>

[[https://github.com/conao3/leaf.el][https://raw.githubusercontent.com/conao3/files/master/blob/headers/png/leaf.el.png]]
[[https://github.com/conao3/leaf.el/blob/master/LICENSE][https://img.shields.io/github/license/conao3/leaf.el.svg?style=flat-square]]
[[https://github.com/conao3/leaf.el/releases][https://img.shields.io/github/tag/conao3/leaf.el.svg?style=flat-square]]
[[https://travis-ci.org/conao3/leaf.el][https://img.shields.io/travis/conao3/leaf.el/master.svg?style=flat-square]]
[[https://app.codacy.com/project/conao3/leaf.el/dashboard][https://img.shields.io/codacy/grade/1a6befcbdfdb4b1fb37a6f7f040a75b2.svg?logo=codacy&style=flat-square]]
[[https://www.patreon.com/conao3][https://img.shields.io/badge/patreon-@conao3-orange.svg?logo=patreon&style=flat-square]]
[[https://twitter.com/conao_3][https://img.shields.io/badge/twitter-@conao__3-blue.svg?logo=twitter&style=flat-square]]
[[https://join.slack.com/t/conao3-support/shared_invite/enQtNTg2MTY0MjkzOTU0LTFjOTdhOTFiNTM2NmY5YTE5MTNlYzNiOTE2MTZlZWZkNDEzZmRhN2E0NjkwMWViZTZiYjA4MDUxYTUzNDZiNjY][https://img.shields.io/badge/chat-on_slack-blue.svg?logo=slack&style=flat-square]]

* Table of Contents
- [[#background][Background]]
- [[#install][Install]]
- [[#usage][Usage]]
- [[https://github.com/conao3/leaf.el#syntaxes][Syntaxes]]
- [[https://github.com/conao3/leaf.el#basic-keywords][Basic keywords]]
  - [[https://github.com/conao3/leaf.el#none-keyword][none (keyword)]]
  - [[https://github.com/conao3/leaf.el#require-keyword][:require keyword]]
  - [[https://github.com/conao3/leaf.el#ensure-keyword][:ensure keyword]]
  - [[https://github.com/conao3/leaf.el#preface-init-config-keywords][:preface :init :config keywords]]
  - [[https://github.com/conao3/leaf.el#commands-keyword][:commands keyword]]
  - [[https://github.com/conao3/leaf.el#after-keyword][:after keyword]]
- [[https://github.com/conao3/leaf.el#configure-variables-keywords][Configure variables keywords]]
  - [[https://github.com/conao3/leaf.el#custom-custom-face--keywords][:custom :custom-face keywords]]
  - [[https://github.com/conao3/leaf.el#pre-setq-setq-setq-default-keywords][:pre-setq :setq :setq-default keywords]]
- [[https://github.com/conao3/leaf.el#configure-list-keywords][Configure list keywords]]
  - [[https://github.com/conao3/leaf.el#mode-interpreter-keywords][:mode :interpreter keywords]]
  - [[https://github.com/conao3/leaf.el#magic-magic-fallback-keywords][:magic :magic-fallback keywords]]
  - [[https://github.com/conao3/leaf.el#hook-keyword][:hook keyword]]
  - [[https://github.com/conao3/leaf.el#load-path-keyword][:load-path keyword]]
- [[https://github.com/conao3/leaf.el#condition-keywords][Condition keywords]]
  - [[https://github.com/conao3/leaf.el#disabled-keywords][:disabled keyword]]
  - [[https://github.com/conao3/leaf.el#if-when-unless-keywords][:if :when :unless keywords]]
- [[https://github.com/conao3/leaf.el#byte-compile-keywords][Byte compile keywords]]
  - [[https://github.com/conao3/leaf.el#defun-defvar-keywords][:defun, :defvar keywords]]
- [[https://github.com/conao3/leaf.el#documentation-keywords][Documentation keywords]]
  - [[https://github.com/conao3/leaf.el#doc-file-url-keywords][:doc, :file, :url keywords]]
- [[https://github.com/conao3/leaf.el#configure-other-packages][Configure other packages]]
  - [[https://github.com/conao3/leaf.el#bind-bind-keywords][:bind, :bind* keywords]]
- [[#information][Information]]
  - [[#donation][Donation]]
  - [[#community][Community]]
  - [[#contribution][Contribution]]
    - [[#leafel-mechanism][leaf.el mechanism]]
      - [[#leaf-name-rest-args-macro][leaf (name &rest args) macro]]
      - [[#leaf-core-name-args-function][leaf-core (name args) function]]
        - [[#leaf-append-defaults-plist-function][leaf-append-defaults (plist) function]]
        - [[#leaf-normalize-plist-plsit-mergep-function][leaf-normalize-plist (plsit mergep) function]]
        - [[#leaf-sort-values-plist-plist-function][leaf-sort-values-plist (plist) function]]
      - [[#leaf-pcocess-keywords-name-plist-function][leaf-pcocess-keywords (name plist) function]]
    - [[#adding-custom-keyword][Adding custom keyword]]
      - [[#add-leaf-keywords][Add leaf keyword(s)]]
      - [[#define-leaf-handler][Define leaf handler]]
    - [[#why-we-support-emacs-22][Why We support Emacs-22?]]
  - [[#migration][Migration]]
    - [[#leaf-v10-to-v20][leaf v1.0 to v2.0]]
  - [[#license][License]]
  - [[#author][Author]]
  - [[#contributors][Contributors]]
  - [[#welcome-pr][Welcome PR]]
  - [[#special-thanks][Special Thanks]]

* Background
~leaf.el~ is yet another [[https://github.com/jwiegley/use-package][use-package]].

~leaf~ solves the stress of using ~use-package~ for 2 years.
By developing from scratch, we have a cleaner and more predictable implementation than ~use-package~.

This makes it easy to maintain and add new keywords.

~leaf~ has keywords almost identical to ~use-package~, but some of usage of the keywords is different.

The quickest way to solve problem is to use ~macroexpand-1~ to see the unfolded result if it is not what you intended.
And also there are also a number of samples in this README and more in the [[https://github.com/conao3/leaf.el/blob/master/leaf-tests.el][test file]].

In addition, since it works with Emacs-22, you can use your usual init.el as usual,
even if you are temporarily using fossil-like Emacs on loan.

(Of course, there are not many packages that work perfectly with Emacs-22.
These packages will be installed by the package manager and will probably report an error.

~leaf~ processes this and cancels the configuration for that package.
It then attempts to process the next package.)

* Install
Put ~leaf.el~ at any folder added ~load-path~.
Then ~(require 'leaf)~ and use like ~use-pacakge~.

In order to work from Emacs-22, the package manager and the key binding manager
that accompanies ~leaf~ must also be developed with the assumption that they will work from Emacs-22.

I have plans to develop it, but it's not finished yet.
It is now necessary to use these packages to avoid trouble.

Package to be developed
- [[https://github.com/conao3/feather.el][feather.el]] instead of package.el
- leaf-key.el instead of bind-keys

#+BEGIN_SRC emacs-lisp
  ;; add to load-path
  ;; (locate-user-emacs-file "site-lisp/leaf.el")
  ;;  => "~/.emacs.d/local/26.1/site-lisp/leaf.el"

  (add-to-list 'load-path (locate-user-emacs-file "site-lisp/leaf.el"))
  (add-to-list 'load-path (locate-user-emacs-file "site-lisp/feather.el"))

  (require 'leaf)

  (custom-set-variables '(leaf-backend-ensure 'package)
                        '(leaf-backend-bind 'bind-key)
                        '(leaf-backend-bind* 'bind-key))

  (leaf package
    :config
    (add-list-to-list 'package-archives
      '(("org"       . "https://orgmode.org/elpa/")
        ("melpa"     . "https://melpa.org/packages/")))
    (package-initialize))

  (leaf bind-key :ensure t)
#+END_SRC

* Usage
Use ~leaf~ in your init.el like ~use-package~.
You declaratively tell the ~leaf~ to configure the package using special keywords.

~leaf~ converts your declaration into Elisp for Emacs to understand, and Emacs executes it to configure the package.

* Syntaxes
All below examples are excerpts from ~leaf-tests.el~.

These examples are defined in the following format.
We expect FORM will be expanded to EXPECT.
#+begin_src emacs-lisp
  (cort-deftest-with-macroexpand TESTCASE-NAME
    '((FORM             ; will be expand by `macroexpand-1'
       EXPECT)          ; expect FORM's expansion will be EXPECT (test by `equal')

      (FORM
       EXPECT)

      ...))
#+end_src

* Basic keywords
** none (keyword)
*Unlike use-package*, ~leaf~ will convert to ~nil~ when used without any keywords.
#+begin_src emacs-lisp
  (cort-deftest-with-macroexpand leaf/none
  '(((leaf leaf)
     nil)))
#+end_src

** :require keyword
If you want to ~require~, you must use the ~:require~ keyword explicitly.

This is ideally the exact opposite of using the ~:no-require~ keyword in the ~use-package~ if you does not want to ~require~ it.

The leaf ~:require~ keyword is powerful, specify ~t~ to require the package, and specify symbols to ~require~ them.

Since the priority is lower than that of the conditional branch keyword described later,
it is possible to assign whether to ~require~ or not by the conditional branch keyword.

#+begin_src emacs-lisp
  (cort-deftest-with-macroexpand leaf/require
    '(((leaf leaf
         :init (leaf-pre-init)
         :require t
         :config (leaf-init))
       (progn
         (leaf-pre-init)
         (require 'leaf)
         (leaf-init)))

      ((leaf leaf
         :init (leaf-pre-init)
         :require nil
         :config (leaf-init))
       (progn
         (leaf-pre-init)
         (leaf-init)))

      ((leaf leaf
         :init (leaf-pre-init)
         :require leaf leaf-polyfill
         :config (leaf-init))
       (progn
         (leaf-pre-init)
         (require 'leaf)
         (require 'leaf-polyfill)
         (leaf-init)))

      ((leaf leaf
         :init (leaf-pre-init)
         :require t
         :require leaf-polyfill
         :config (leaf-init))
       (progn
         (leaf-pre-init)
         (require 'leaf)
         (require 'leaf-polyfill)
         (leaf-init)))

      ((leaf leaf
         :init (leaf-pre-init)
         :require t leaf-polyfill
         :config (leaf-init))
       (progn
         (leaf-pre-init)
         (require 'leaf)
         (require 'leaf-polyfill)
         (leaf-init)))

      ((leaf leaf
         :init (leaf-pre-init)
         :require (leaf leaf-polyfill leaf-sub leaf-subsub)
         :config (leaf-init))
       (progn
         (leaf-pre-init)
         (require 'leaf)
         (require 'leaf-polyfill)
         (require 'leaf-sub)
         (require 'leaf-subsub)
         (leaf-init)))))
#+end_src

** :ensure keyword
~:ensure~ provide package manager frontend
for example, ~feather.el~ and ~package.el~ etc...

You can customize backend to process ~:ensure~ keyword.
#+BEGIN_SRC emacs-lisp
  ;; use package.el as :ensure backend
  (setq leaf-backend-ensure 'package)

  ;; use feather.el as :ensure backend
  (setq leaf-backend-ensure 'feather)

  ;; use no package as :ensure backend (disable :ensure)
  (setq leaf-backend-ensure nil)
#+END_SRC

~leaf.el~ prepared ~feather.el~ and ~package.el~ backend,
but it's easy to create other package manager's backend.

Of course, loading and setting of the package manager itself must be
completed before using ~:ensure~ keyword.

# #+BEGIN_SRC emacs-lisp
#   (cort-deftest leaf-test/:simple-ensure  ;
#     (match-expansion-let ((leaf-backend/:ensure 'package))
#       (leaf foo :ensure t)
#       '(progn
#          (funcall #'leaf-backend/:ensure-package 'foo 'foo)
#          (progn))))
# #+END_SRC

** :preface, :init, :config keywords
These keywords are provided to directly describe elisp with various settings that ~leaf~ does not support.

These keywords are provided to control where the arguments expand,
- ~:preface~ expands before the conditional branch keyword
- ~:init~ expands after the conditional branch keyword (~:if~ ~when~ ~unless~) before ~:require~
- ~:config~ expands after ~:require~

You don't need to put ~progn~ because ~leaf~ can receive multiple S-expressions, but you can do so if you prefer it.

#+begin_src emacs-lisp
  (cort-deftest-with-macroexpand leaf/preface
    '(((leaf leaf
         :init (leaf-pre-init)
         :require t
         :config (leaf-init))
       (progn
         (leaf-pre-init)
         (require 'leaf)
         (leaf-init)))

      ((leaf leaf
         :preface (progn
                    (leaf-pre-init)
                    (leaf-pre-init-after))
         :require t
         :config (leaf-init))
       (progn
         (progn
           (leaf-pre-init)
           (leaf-pre-init-after))
         (require 'leaf)
         (leaf-init)))

      ((leaf leaf
         :preface
         (leaf-pre-init)
         (leaf-pre-init-after)
         :require t
         :config (leaf-init))
       (progn
         (leaf-pre-init)
         (leaf-pre-init-after)
         (require 'leaf)
         (leaf-init)))

      ((leaf leaf
         :preface (preface-init)
         :when (some-condition)
         :require t
         :init (package-preconfig)
         :config (package-init))
       (progn
         (preface-init)
         (when (some-condition)
           (package-preconfig)
           (require 'leaf)
           (package-init))))))
#+end_src

** :commands keyword
~commands~ keyword configures ~autoload~.
#+begin_src emacs-lisp
  (cort-deftest-with-macroexpand leaf/commands
    '(((leaf leaf
         :commands leaf
         :config (leaf-init))
       (progn
         (autoload #'leaf "leaf" nil t)
         (leaf-init)))

      ((leaf leaf
         :commands leaf leaf-pairp leaf-plist-get)
       (progn
         (autoload #'leaf "leaf" nil t)
         (autoload #'leaf-pairp "leaf" nil t)
         (autoload #'leaf-plist-get "leaf" nil t)))

      ((leaf leaf
         :commands leaf (leaf-pairp leaf-plist-get))
       (progn
         (autoload #'leaf "leaf" nil t)
         (autoload #'leaf-pairp "leaf" nil t)
         (autoload #'leaf-plist-get "leaf" nil t)))))
#+end_src

** :after keyword
~:after~ keyword configure loading order.

*Currently it does not support or :after like use-package.*
#+begin_src emacs-lisp
(cort-deftest-with-macroexpand leaf/after
  '(((leaf leaf-browser
       :after leaf
       :require t
       :config (leaf-browser-init))
     (progn
       (eval-after-load 'leaf
         '(progn
            (require 'leaf-browser)
            (leaf-browser-init)))))

    ((leaf leaf-browser
       :after leaf org orglyth
       :require t
       :config (leaf-browser-init))
     (progn
       (eval-after-load 'orglyth
         '(eval-after-load 'org
            '(eval-after-load 'leaf
               '(progn
                  (require 'leaf-browser)
                  (leaf-browser-init)))))))

    ((leaf leaf-browser
       :after leaf (org orglyth)
       :require t
       :config (leaf-browser-init))
     (progn
       (eval-after-load 'orglyth
         '(eval-after-load 'org
            '(eval-after-load 'leaf
               '(progn
                  (require 'leaf-browser)
                  (leaf-browser-init)))))))))
#+end_src

** COMMENT :defaults keyword
~:defalts~ provide to download recommended settings for specified package.
For more detail, see [[https://github.com/conao3/leaf-defaults.git][leaf-defaults]].
#+BEGIN_SRC emacs-lisp
  (cort-deftest leaf-test/:simple-defaults
    (match-expansion-let ((leaf-backend/:ensure 'package))
     (leaf foo :ensure t :defaults t)
     '(progn
        (funcall #'leaf-backend/:ensure-package 'foo 'foo)
        (feather-install-defaults 'foo)
        (progn))))
#+END_SRC

* Configure variables keywords
** :custom, :custom-face keywords
Now that the proper Elisp packaging practices have become widely known,
it is a best practice to use ~custom-set-variables~ to customize packages.

*Unlike use-package*, you must specify a dot pair.

You can of course set multiple variables, you can set multiple variables to the same value,
or you can set the evaluation result of the S expression to a variable.

The value set to ~custom-face~ should also be quoed to emphasize uniformity as ~leaf~.

#+begin_src emacs-lisp
  (cort-deftest-with-macroexpand leaf/custom
    '(((leaf leaf
         :custom ((leaf-backend-ensure . 'feather)
                  (leaf-backend-bind   . 'bind-key)
                  (leaf-backend-bind*  . 'bind-key)))
       (progn
         (custom-set-variables
          '(leaf-backend-ensure 'feather "Customized with leaf in leaf block")
          '(leaf-backend-bind 'bind-key "Customized with leaf in leaf block")
          '(leaf-backend-bind* 'bind-key "Customized with leaf in leaf block"))))

      ((leaf leaf
         :custom
         (leaf-backend-ensure . 'feather)
         (leaf-backend-bind   . 'bind-key)
         (leaf-backend-bind*  . 'bind-key))
       (progn
         (custom-set-variables
          '(leaf-backend-ensure 'feather "Customized with leaf in leaf block")
          '(leaf-backend-bind 'bind-key "Customized with leaf in leaf block")
          '(leaf-backend-bind* 'bind-key "Customized with leaf in leaf block"))))

      ((leaf leaf
         :custom ((leaf-backend-bind leaf-backend-bind*) . 'bind-key))
       (progn
         (custom-set-variables
          '(leaf-backend-bind 'bind-key "Customized with leaf in leaf block")
          '(leaf-backend-bind* 'bind-key "Customized with leaf in leaf block"))))))

  (cort-deftest-with-macroexpand leaf/custom-face
    '(((leaf eruby-mode
         :custom-face
         (eruby-standard-face . '((t (:slant italic)))))
       (progn
         (custom-set-faces '(eruby-standard-face (((t (:slant italic))))))))

      ((leaf eruby-mode
         :custom-face
         ((default eruby-standard-face) . '((t (:slant italic)))))
       (progn
         (custom-set-faces
          '(default (((t (:slant italic)))))
          '(eruby-standard-face (((t (:slant italic))))))))))
#+end_src

** :pre-setq, :setq, :setq-default keywords
These keywords provide a front end to just ~setq~, ~setq-default~.

Because there are packages in the world that must be ~setq~ before doing ~require~ them,
the ~:pre-setq~ keyword is also provided to accommodate them.

The argument specified for ~:pre-setq~ is expanded before ~:require~.

You can of course configure multiple variables, set multiple variables to the same value,
or set the evaluation result of some S expression to variable.
#+begin_src emacs-lisp
  (cort-deftest-with-macroexpand leaf/setq
    '(((leaf alloc
         :setq `((gc-cons-threshold . ,(* 512 1024 1024))
                 (garbage-collection-messages . t))
         :require t)
       (progn
         (require 'alloc)
         (setq gc-cons-threshold 536870912)
         (setq garbage-collection-messages t)))

      ((leaf alloc
         :setq ((gc-cons-threshold . 536870912)
                (garbage-collection-messages . t))
         :require t)
       (progn
         (require 'alloc)
         (setq gc-cons-threshold 536870912)
         (setq garbage-collection-messages t)))

      ((leaf leaf
         :setq
         (leaf-backend-bind . 'bind-key)
         (leaf-backend-bind* . 'bind-key)
         :require t)
       (progn
         (require 'leaf)
         (setq leaf-backend-bind 'bind-key)
         (setq leaf-backend-bind* 'bind-key)))

      ((leaf leaf
         :setq (leaf-backend-bind leaf-backend-bind* . 'bind-key)
         :require t)
       (progn
         (require 'leaf)
         (setq leaf-backend-bind 'bind-key)
         (setq leaf-backend-bind* 'bind-key)))

      ((leaf leaf
         :setq ((leaf-backend-bind leaf-backend-bind*) . 'bind-key)
         :require t)
       (progn
         (require 'leaf)
         (setq leaf-backend-bind 'bind-key)
         (setq leaf-backend-bind* 'bind-key)))))

  (cort-deftest-with-macroexpand leaf/pre-setq
    '(((leaf leaf
         :pre-setq ((leaf-backend-bind leaf-backend-bind*) . 'bind-key)
         :require t)
       (progn
         (setq leaf-backend-bind 'bind-key)
         (setq leaf-backend-bind* 'bind-key)
         (require 'leaf)))))

  (cort-deftest-with-macroexpand leaf/setq-default
    '(((leaf alloc
         :setq-default `((gc-cons-threshold . ,(* 512 1024 1024))
                         (garbage-collection-messages . t))
         :require t)
       (progn
         (require 'alloc)
         (setq-default gc-cons-threshold 536870912)
         (setq-default garbage-collection-messages t)))
      ))
#+end_src

* Configure list keywords
** :mode, :interpreter keywords
~:mode~ keyword define ~auto-mode-alist~. Specifies the major-mode to enable by file extension.
~:interpreter~ keyword define ~interpreter-mode-alist~. Specifies the major-mode to enable by file shebang.

If you pass symbol to these keyword, use leaf block name as major-mode.
If you want to specify major-mode, pass dotted pair value.
#+begin_src emacs-lisp
  (cort-deftest-with-macroexpand leaf/mode
    '(((leaf web-mode
         :mode "\\.js\\'" "\\.p?html?\\'")
       (progn
         (autoload #'web-mode "web-mode" nil t)
         (add-to-list 'auto-mode-alist '("\\.js\\'" web-mode))
         (add-to-list 'auto-mode-alist '("\\.p?html?\\'" web-mode))))

      ((leaf web-mode
         :mode ("\\.js\\'" "\\.p?html?\\'"))
       (progn
         (autoload #'web-mode "web-mode" nil t)
         (add-to-list 'auto-mode-alist '("\\.js\\'" web-mode))
         (add-to-list 'auto-mode-alist '("\\.p?html?\\'" web-mode))))

      ((leaf web-mode
         :mode (("\\.js\\'" "\\.p?html?\\'") . web-mode))
       (progn
         (autoload #'web-mode "web-mode" nil t)
         (add-to-list 'auto-mode-alist '("\\.js\\'" web-mode))
         (add-to-list 'auto-mode-alist '("\\.p?html?\\'" web-mode))))

      ((leaf web-mode
         :mode (("\\.phtml?\\'" "\\.html?\\'" . web-html-mode) "\\.js\\'" . web-mode))
       (progn
         (autoload #'web-html-mode "web-mode" nil t)
         (autoload #'web-mode "web-mode" nil t)
         (add-to-list 'auto-mode-alist '("\\.phtml?\\'" web-html-mode))
         (add-to-list 'auto-mode-alist '("\\.html?\\'" web-html-mode))
         (add-to-list 'auto-mode-alist '("\\.js\\'" web-mode))))))

  (cort-deftest-with-macroexpand leaf/interpreter
    '(((leaf ruby-mode
         :mode "\\.rb\\'" "\\.rb2\\'" ("\\.rbg\\'" . rb-mode)
         :interpreter "ruby")
       (progn
         (autoload #'ruby-mode "ruby-mode" nil t)
         (autoload #'rb-mode "ruby-mode" nil t)
         (add-to-list 'auto-mode-alist '("\\.rb\\'" ruby-mode))
         (add-to-list 'auto-mode-alist '("\\.rb2\\'" ruby-mode))
         (add-to-list 'auto-mode-alist '("\\.rbg\\'" rb-mode))
         (add-to-list 'interpreter-mode-alist '("ruby" ruby-mode))))

      ((leaf web-mode
         :interpreter "js" "p?html?")
       (progn
         (autoload #'web-mode "web-mode" nil t)
         (add-to-list 'interpreter-mode-alist '("js" web-mode))
         (add-to-list 'interpreter-mode-alist '("p?html?" web-mode))))

      ((leaf web-mode
         :interpreter ("js" "p?html?"))
       (progn
         (autoload #'web-mode "web-mode" nil t)
         (add-to-list 'interpreter-mode-alist '("js" web-mode))
         (add-to-list 'interpreter-mode-alist '("p?html?" web-mode))))

      ((leaf web-mode
         :interpreter ("js" ("p?html?")))
       (progn
         (autoload #'web-mode "web-mode" nil t)
         (add-to-list 'interpreter-mode-alist '("js" web-mode))
         (add-to-list 'interpreter-mode-alist '("p?html?" web-mode))))

      ((leaf web-mode
         :interpreter (("js" "p?html?") . web-mode))
       (progn
         (autoload #'web-mode "web-mode" nil t)
         (add-to-list 'interpreter-mode-alist '("js" web-mode))
         (add-to-list 'interpreter-mode-alist '("p?html?" web-mode))))

      ((leaf web-mode
         :interpreter (("phtml?" "html?" . web-html-mode) "js" . web-mode))
       (progn
         (autoload #'web-html-mode "web-mode" nil t)
         (autoload #'web-mode "web-mode" nil t)
         (add-to-list 'interpreter-mode-alist '("phtml?" web-html-mode))
         (add-to-list 'interpreter-mode-alist '("html?" web-html-mode))
         (add-to-list 'interpreter-mode-alist '("js" web-mode))))))
#+end_src

** :magic, :magic-fallback keywords
~:magic~ keyword define ~magic-mode-alist~. It is used to determine major-mode in binary header byte.

~:magic-fallback~ keyward also define ~magic-fallback-alist~.
#+begin_src emacs-lisp
  (cort-deftest-with-macroexpand leaf/magic
    '(((leaf pdf-tools
         :magic ("%PDF" . pdf-view-mode)
         :config
         (pdf-tools-install))
       (progn
         (autoload #'pdf-view-mode "pdf-tools" nil t)
         (add-to-list 'magic-mode-alist '("%PDF" pdf-view-mode))
         (pdf-tools-install)))

      ((leaf web-mode
         :magic "js" "p?html?")
       (progn
         (autoload #'web-mode "web-mode" nil t)
         (add-to-list 'magic-mode-alist '("js" web-mode))
         (add-to-list 'magic-mode-alist '("p?html?" web-mode))))

      ((leaf web-mode
         :magic ("js" "p?html?"))
       (progn
         (autoload #'web-mode "web-mode" nil t)
         (add-to-list 'magic-mode-alist '("js" web-mode))
         (add-to-list 'magic-mode-alist '("p?html?" web-mode))))

      ((leaf web-mode
         :magic ("js" ("p?html?")))
       (progn
         (autoload #'web-mode "web-mode" nil t)
         (add-to-list 'magic-mode-alist '("js" web-mode))
         (add-to-list 'magic-mode-alist '("p?html?" web-mode))))

      ((leaf web-mode
         :magic (("js" "p?html?") . web-mode))
       (progn
         (autoload #'web-mode "web-mode" nil t)
         (add-to-list 'magic-mode-alist '("js" web-mode))
         (add-to-list 'magic-mode-alist '("p?html?" web-mode))))

      ((leaf web-mode
         :magic (("phtml?" "html?" . web-html-mode) "js" . web-mode))
       (progn
         (autoload #'web-html-mode "web-mode" nil t)
         (autoload #'web-mode "web-mode" nil t)
         (add-to-list 'magic-mode-alist '("phtml?" web-html-mode))
         (add-to-list 'magic-mode-alist '("html?" web-html-mode))
         (add-to-list 'magic-mode-alist '("js" web-mode))))))

  (cort-deftest-with-macroexpand leaf/magic-fallback
    '(((leaf pdf-tools
         :magic-fallback ("%PDF" . pdf-view-mode)
         :config
         (pdf-tools-install))
       (progn
         (autoload #'pdf-view-mode "pdf-tools" nil t)
         (add-to-list 'magic-fallback-mode-alist '("%PDF" pdf-view-mode))
         (pdf-tools-install)))

      ((leaf web-mode
         :magic-fallback "js" "p?html?")
       (progn
         (autoload #'web-mode "web-mode" nil t)
         (add-to-list 'magic-fallback-mode-alist '("js" web-mode))
         (add-to-list 'magic-fallback-mode-alist '("p?html?" web-mode))))

      ((leaf web-mode
         :magic-fallback ("js" "p?html?"))
       (progn
         (autoload #'web-mode "web-mode" nil t)
         (add-to-list 'magic-fallback-mode-alist '("js" web-mode))
         (add-to-list 'magic-fallback-mode-alist '("p?html?" web-mode))))

      ((leaf web-mode
         :magic-fallback (("js" "p?html?") . web-mode))
       (progn
         (autoload #'web-mode "web-mode" nil t)
         (add-to-list 'magic-fallback-mode-alist '("js" web-mode))
         (add-to-list 'magic-fallback-mode-alist '("p?html?" web-mode))))

      ((leaf web-mode
         :magic-fallback (("phtml?" "html?" . web-html-mode) "js" . web-mode))
       (progn
         (autoload #'web-html-mode "web-mode" nil t)
         (autoload #'web-mode "web-mode" nil t)
         (add-to-list 'magic-fallback-mode-alist '("phtml?" web-html-mode))
         (add-to-list 'magic-fallback-mode-alist '("html?" web-html-mode))
         (add-to-list 'magic-fallback-mode-alist '("js" web-mode))))))
#+end_src

** :hook keyword
~:hook~ keyword define ~add-hook~ (add-to-list ~*-hook~).

#+begin_src emacs-lisp
  (cort-deftest-with-macroexpand leaf/hook
    '(((leaf ace-jump-mode
         :hook cc-mode-hook)
       (progn
         (autoload #'ace-jump-mode "ace-jump-mode" nil t)
         (add-hook 'cc-mode-hook #'ace-jump-mode)))

      ((leaf ace-jump-mode
         :hook cc-mode-hook prog-mode-hook)
       (progn
         (autoload #'ace-jump-mode "ace-jump-mode" nil t)
         (add-hook 'cc-mode-hook #'ace-jump-mode)
         (add-hook 'prog-mode-hook #'ace-jump-mode)))

      ((leaf ace-jump-mode
         :hook cc-mode-hook (prog-mode-hook . my-ace-jump-mode))
       (progn
         (autoload #'ace-jump-mode "ace-jump-mode" nil t)
         (autoload #'my-ace-jump-mode "ace-jump-mode" nil t)
         (add-hook 'cc-mode-hook #'ace-jump-mode)
         (add-hook 'prog-mode-hook #'my-ace-jump-mode)))

      ((leaf ace-jump-mode
         :hook ((cc-mode-hook prog-mode-hook) . my-ace-jump-mode))
       (progn
         (autoload #'my-ace-jump-mode "ace-jump-mode" nil t)
         (add-hook 'cc-mode-hook #'my-ace-jump-mode)
         (add-hook 'prog-mode-hook #'my-ace-jump-mode)))

      ((leaf ace-jump-mode
         :hook ((cc-mode-hook prog-mode-hook . ace-jump-mode) isearch-mode . my-ace-jump-mode))
       (progn
         (autoload #'ace-jump-mode "ace-jump-mode" nil t)
         (autoload #'my-ace-jump-mode "ace-jump-mode" nil t)
         (add-hook 'cc-mode-hook #'ace-jump-mode)
         (add-hook 'prog-mode-hook #'ace-jump-mode)
         (add-hook 'isearch-mode #'my-ace-jump-mode)))))
#+end_src
** :load-path keyword
*Unlike use-package*, you must specify the full path.

Use backquotes if you want the path to be relative to the current ~.emacs.d~, such as use-package.

#+begin_src emacs-lisp
  (cort-deftest-with-macroexpand leaf/load-path
    '(((leaf leaf
         :load-path "~/.emacs.d/elpa-archive/leaf.el/"
         :require t
         :config (leaf-init))
       (progn
         (add-to-list 'load-path "~/.emacs.d/elpa-archive/leaf.el/")
         (require 'leaf)
         (leaf-init)))

      ((leaf leaf
         :load-path
         "~/.emacs.d/elpa-archive/leaf.el/"
         "~/.emacs.d/elpa-archive/leaf-browser.el/"
         :require t
         :config (leaf-init))
       (progn
         (add-to-list 'load-path "~/.emacs.d/elpa-archive/leaf.el/")
         (add-to-list 'load-path "~/.emacs.d/elpa-archive/leaf-browser.el/")
         (require 'leaf)
         (leaf-init)))

      ((leaf leaf
         :load-path ("~/.emacs.d/elpa-archive/leaf.el/"
                     "~/.emacs.d/elpa-archive/leaf-browser.el/")
         :require t
         :config (leaf-init))
       (progn
         (add-to-list 'load-path "~/.emacs.d/elpa-archive/leaf.el/")
         (add-to-list 'load-path "~/.emacs.d/elpa-archive/leaf-browser.el/")
         (require 'leaf)
         (leaf-init)))

      ((leaf leaf
         :load-path ("~/.emacs.d/elpa-archive/leaf.el/")
         :load-path `(,(mapcar (lambda (elm)
                                 (concat "~/.emacs.d/elpa-archive/" elm "/"))
                               '("leaf.el" "leaf-broser.el" "orglyth.el")))
         :require t
         :config (leaf-init))
       (progn
         (add-to-list 'load-path "~/.emacs.d/elpa-archive/leaf.el/")
         (add-to-list 'load-path "~/.emacs.d/elpa-archive/leaf-broser.el/")
         (add-to-list 'load-path "~/.emacs.d/elpa-archive/orglyth.el/")
         (require 'leaf)
         (leaf-init)))

      ((leaf leaf
         :load-path `,(locate-user-emacs-file "leaf.el")
         :require t
         :config (leaf-init))
       (progn
         (add-to-list 'load-path "~/.emacs.d/local/26.1/leaf.el")
         (require 'leaf)
         (leaf-init)))

      ((leaf leaf
         :load-path `(,(mapcar #'locate-user-emacs-file
                               '("leaf.el" "leaf-broser.el" "orglyth.el")))
         :require t
         :config (leaf-init))
       (progn
         (add-to-list 'load-path "~/.emacs.d/local/26.1/local/leaf.el")
         (add-to-list 'load-path "~/.emacs.d/local/26.1/local/leaf-broser.el")
         (add-to-list 'load-path "~/.emacs.d/local/26.1/local/orglyth.el")
         (require 'leaf)
         (leaf-init)))))
#+end_src

* Condition keywords
** :disabled keyword
The ~:disabled~ keyword provides the ability to temporarily~ nil~ the output of that ~leaf~ block.

You can use multiple values for the ~:disabled~ keyword, or multiple ~:disabled~ keyword,
but ~:disabled~ only respects the value specified at the top.

It can also be said that old values can be overridden by described above.

As you can see from the internal structure of ~:disabled~,
you do not need to pass an exact ~t~ to convert it to ~nil~ because it is comparing it by ~unless~.

#+begin_src emacs-lisp
  (defvar leaf-keywords
    '(:dummy
      :disabled (unless (eval (car value)) `(,@body))
      ...))
#+end_src

#+begin_src emacs-lisp
  (cort-deftest-with-macroexpand leaf/disabled
    '(((leaf leaf :disabled t       :config (leaf-init))
       nil)

      ((leaf leaf :disabled nil     :config (leaf-init))
       (progn
         (leaf-init)))

      ((leaf leaf :disabled nil t   :config (leaf-init))
       (progn
         (leaf-init)))

      ((leaf leaf :disabled t :disabled nil     :config (leaf-init))
       nil)))
#+end_src

** :if, :when, :unless keywords
~:if~, ~:when~, ~:unless~ keywords expect sexp return boolean or just boolean value
and wrap converted sexp specified function.

If specified multiple those keywords, evaluate sexp in ~and~.
#+begin_src emacs-lisp
  (cort-deftest-with-macroexpand leaf/if
    '(((leaf leaf
         :if leafp
         :require t
         :config (leaf-init))
       (progn
         (if leafp
             (progn
               (require 'leaf)
               (leaf-init)))))

      ((leaf leaf
         :if leafp leaf-avairablep (window-system)
         :require t
         :config (leaf-init))
       (progn
         (if (and leafp leaf-avairablep (window-system))
             (progn
               (require 'leaf)
               (leaf-init)))))

      ((leaf leaf
         :if leafp leaf-avairablep (window-system)
         :when leaf-browserp
         :require t
         :config (leaf-init))
       (progn
         (when leaf-browserp
           (if (and leafp leaf-avairablep (window-system))
               (progn
                 (require 'leaf)
                 (leaf-init))))))

      ((leaf leaf
         :if leafp leaf-avairablep (window-system)
         :when leaf-browserp
         :load-path "~/.emacs.d/elpa-archive/leaf.el/"
         :preface (leaf-load)
         :require t
         :config (leaf-init))
       (progn
         (add-to-list 'load-path "~/.emacs.d/elpa-archive/leaf.el/")
         (leaf-load)
         (when leaf-browserp
           (if (and leafp leaf-avairablep (window-system))
               (progn
                 (require 'leaf)
                 (leaf-init))))))))
  
  (cort-deftest-with-macroexpand leaf/when
    '(((leaf leaf
         :when leafp
         :require t
         :config (leaf-init))
       (progn
         (when leafp
           (require 'leaf)
           (leaf-init))))

      ((leaf leaf
         :when leafp leaf-avairablep (window-system)
         :require t
         :config (leaf-init))
       (progn
         (when (and leafp leaf-avairablep (window-system))
           (require 'leaf)
           (leaf-init))))))

  (cort-deftest-with-macroexpand leaf/unless
    '(((leaf leaf
         :unless leafp
         :require t
         :config (leaf-init))
       (progn
         (unless leafp
           (require 'leaf)
           (leaf-init))))

      ((leaf leaf
         :unless leafp leaf-avairablep (window-system)
         :require t
         :config (leaf-init))
       (progn
         (unless (and leafp leaf-avairablep (window-system))
           (require 'leaf)
           (leaf-init))))))
#+end_src

* Byte compile keywords
** :defun, :defvar keywords
To suppress byte compilation warnings, you must make the appropriate declarations in Elisp to tell Emacs
that you are making the appropriate calls.

This is usually done by a ~declare-function~ and an empty ~defvar~, and ~leaf~ provides a front end to it.

#+BEGIN_SRC emacs-lisp
  (cort-deftest-with-macroexpand leaf/defun
    '(((leaf leaf
         :defun leaf leaf-normalize-plist leaf-merge-dupkey-values-plist)
       (progn
         (declare-function leaf "leaf")
         (declare-function leaf-normalize-plist "leaf")
         (declare-function leaf-merge-dupkey-values-plist "leaf")))

      ((leaf leaf
         :defun (leaf leaf-normalize-plist leaf-merge-dupkey-values-plist))
       (progn
         (declare-function leaf "leaf")
         (declare-function leaf-normalize-plist "leaf")
         (declare-function leaf-merge-dupkey-values-plist "leaf")))

      ((leaf leaf
         :defun (lbrowser-open lbrowser-close . leaf-browser))
       (progn
         (declare-function lbrowser-open "leaf-browser")
         (declare-function lbrowser-close "leaf-browser")))

      ((leaf leaf
         :defun ((lbrowser-open (lbrowser-close) . leaf) . leaf-browser))
       (progn
         (declare-function lbrowser-open "leaf")
         (declare-function lbrowser-close "leaf")))

      ((leaf leaf
         :defun ((lbrowser-open (lbrowser-close) . leaf) leaf-asdf . leaf-browser))
       (progn
         (declare-function lbrowser-open "leaf")
         (declare-function lbrowser-close "leaf")
         (declare-function leaf-asdf "leaf-browser")))))

  (cort-deftest-with-macroexpand leaf/defvar
    '(((leaf leaf
         :defvar leaf leaf-normalize-plist leaf-merge-dupkey-values-plist)
       (progn
         (defvar leaf)
         (defvar leaf-normalize-plist)
         (defvar leaf-merge-dupkey-values-plist)))

      ((leaf leaf
         :defvar (leaf leaf-normalize-plist leaf-merge-dupkey-values-plist))
       (progn
         (defvar leaf)
         (defvar leaf-normalize-plist)
         (defvar leaf-merge-dupkey-values-plist)))

      ((leaf leaf
         :defvar (leaf
                   (leaf-normalize-plist
                    (leaf-merge-dupkey-values-plist))))
       (progn
         (defvar leaf)
         (defvar leaf-normalize-plist)
         (defvar leaf-merge-dupkey-values-plist)))))
#+END_SRC

* Documentation keywords
** :doc, :file, :url keywords
The leaf can describe the document systematically.

It should be possible to develop additional packages
that use the value specified for the document keyword, which is not currently used.

The arguments specified for this keyword have no effect on the result of the conversion.

#+BEGIN_SRC emacs-lisp
  (cort-deftest-with-macroexpand leaf/doc
    '(((leaf leaf
         :doc "Symplify init.el configuration"
         :config (leaf-init))
       (progn
         (leaf-init)))

      ((leaf leaf
         :file "~/.emacs.d/elpa/leaf.el/leaf.el"
         :config (leaf-init))
       (progn
         (leaf-init)))

      ((leaf leaf
         :url "https://github.com/conao3/leaf.el"
         :config (leaf-init))
       (progn
         (leaf-init)))

      ((leaf leaf
         :doc "Symplify init.el configuration"
         :file "~/.emacs.d/elpa/leaf.el/leaf.el"
         :url "https://github.com/conao3/leaf.el"
         :config (leaf-init))
       (progn
         (leaf-init)))

      ((leaf leaf
         :doc "Symplify init.el configuration"
         "
  (leaf leaf
    :doc \"Symplify init.el configuration\"
    :config (leaf-init))
   => (progn
        (leaf-init))"
         "
  (leaf leaf
    :disabled nil
    :config (leaf-init))
   => (progn
        (leaf-init))"
         :file "~/.emacs.d/elpa/leaf.el/leaf.el"
         :url "https://github.com/conao3/leaf.el"
         :config (leaf-init))
       (progn
         (leaf-init)))))
#+END_SRC

* Configure other packages
** :bind, :bind* keywords
~:bind~ and ~:bind*~ provide frontend for keybind manager.

When defined globally, key bindings and their corresponding functions are specified in dotted pairs.

To set it to a specific map, *place the map name as a symbol* at the top of the list.

These keywords can also be used in lists. Note that these require a *symbol with the map name at the top of the list*.

Currently, ~leaf~ support ~:package~ ~:prefix~ ~:prefix-map~ ~:menu-name~ ~:filter~ additional keywords.

see more in ~bink-keys~ info.

#+begin_src emacs-lisp
  (cort-deftest-with-macroexpand leaf/bind
    '(((leaf color-moccur
         :bind
         ("M-s O" . moccur)
         ("M-o" . isearch-moccur)
         ("M-O" . isearch-moccur-all))
       (progn
         (autoload #'moccur "color-moccur" nil t)
         (autoload #'isearch-moccur "color-moccur" nil t)
         (autoload #'isearch-moccur-all "color-moccur" nil t)
         (bind-keys :package color-moccur ("M-s O" . moccur))
         (bind-keys :package color-moccur ("M-o" . isearch-moccur))
         (bind-keys :package color-moccur ("M-O" . isearch-moccur-all))))

      ((leaf color-moccur
         :bind (("M-s O" . moccur)
                ("M-o" . isearch-moccur)
                ("M-O" . isearch-moccur-all)))
       (progn
         (autoload #'moccur "color-moccur" nil t)
         (autoload #'isearch-moccur "color-moccur" nil t)
         (autoload #'isearch-moccur-all "color-moccur" nil t)
         (bind-keys :package color-moccur ("M-s O" . moccur))
         (bind-keys :package color-moccur ("M-o" . isearch-moccur))
         (bind-keys :package color-moccur ("M-O" . isearch-moccur-all))))

      ((leaf color-moccur
         :bind (("M-s O" . moccur)
                (("M-o" . isearch-moccur)
                 (("M-O" . isearch-moccur-all)))))
       (progn
         (autoload #'moccur "color-moccur" nil t)
         (autoload #'isearch-moccur "color-moccur" nil t)
         (autoload #'isearch-moccur-all "color-moccur" nil t)
         (bind-keys :package color-moccur ("M-s O" . moccur))
         (bind-keys :package color-moccur ("M-o" . isearch-moccur))
         (bind-keys :package color-moccur ("M-O" . isearch-moccur-all))))

      ((leaf color-moccur
         :bind (("M-s O" . moccur)
                (:isearch-mode-map
                 ("M-o" . isearch-moccur)
                 ("M-O" . isearch-moccur-all))))
       (progn
         (autoload #'moccur "color-moccur" nil t)
         (autoload #'isearch-moccur "color-moccur" nil t)
         (autoload #'isearch-moccur-all "color-moccur" nil t)
         (bind-keys :package color-moccur ("M-s O" . moccur))
         (bind-keys :map isearch-mode-map :package color-moccur ("M-o" . isearch-moccur))
         (bind-keys :map isearch-mode-map :package color-moccur ("M-O" . isearch-moccur-all))))

      ((leaf color-moccur
         :bind (("M-s O" . moccur)
                (:isearch-mode-map
                 :package isearch
                 ("M-o" . isearch-moccur)
                 ("M-O" . isearch-moccur-all))))
       (progn
         (autoload #'moccur "color-moccur" nil t)
         (autoload #'isearch-moccur "color-moccur" nil t)
         (autoload #'isearch-moccur-all "color-moccur" nil t)
         (bind-keys :package color-moccur ("M-s O" . moccur))
         (bind-keys :map isearch-mode-map :package isearch ("M-o" . isearch-moccur))
         (bind-keys :map isearch-mode-map :package isearch ("M-O" . isearch-moccur-all))))))
#+end_src

* Information
** Donation
I love OSS and I am dreaming of working on it as *full-time* job.

*With your support*, I will be able to spend more time at OSS!

[[https://www.patreon.com/conao3][https://c5.patreon.com/external/logo/become_a_patron_button.png]]

** Community
All feedback and suggestions are welcome!

You can use github issues, but you can also use [[https://join.slack.com/t/conao3-support/shared_invite/enQtNTg2MTY0MjkzOTU0LTFjOTdhOTFiNTM2NmY5YTE5MTNlYzNiOTE2MTZlZWZkNDEzZmRhN2E0NjkwMWViZTZiYjA4MDUxYTUzNDZiNjY][Slack]]
if you want a more casual conversation.

** Contribution
We welcome PR!
Travis Cl test ~leaf-test.el~ with all Emacs version 23 or above.

I think that it is difficult to prepare the environment locally,
so I think that it is good to throw PR and test Travis for the time being!
Feel free throw PR!

~leaf.el~ creates the intended elisp code from DSL with a simple mechanism.

It is clear what internal conversion is done and it is also easy to customize it.
*** leaf.el mechanism
**** ~leaf (name &rest args)~ macro
This is ~leaf.el~ frontend macro. Users use only this macro.

Process.
1. Pass arguments to ~leaf-core~.

**** ~leaf-core (name args)~ function
This is the core process for leaf macro expansion.

Process.
1. ~leaf-append-defaults~ to append default value (~leaf-defaults~) to ARGS
2. ~leaf-normalize-plist~ to normalize pseudo-plist, ARGS
3. ~leaf-sort-values-plist~ to sort ARGS
4. pass NAME and ARGS to ~leaf-process-keywords~

***** ~leaf-append-defaults (plist)~ function
Append leaf default values to PLIST.
See ~leaf-defaults~. You can customize this value.

EXAMPLE:
#+BEGIN_SRC emacs-lisp
  (leaf-append-defaults nil)
  -> (:init nil)

  (leaf-append-defaults '(:require foo))
  -> (:require foo :init nil)
#+END_SRC

***** ~leaf-normalize-plist (plsit mergep)~ function
Given a pseudo-PLIST, return PLIST,
if MERGEP is t, return well-formed PLIST.

MERGEP every ~t~ in leaf.

EXAMPLE:
#+BEGIN_SRC emacs-lisp
  (leaf-normalize-plist
    '(:defer t
      :config (message "a") (message "b")
      :config (message "c")) nil)
   -> (:defer (t)
       :config ((message "a") (message "b"))
       :config ((message "c")))

  (leaf-normalize-plist
    '(:defer t
      :config (message "a") (message "b")
      :config (message "c")) t)
   -> (:defer (t)
       :config ((message "a") (message "b") (message "c"))
#+END_SRC

***** ~leaf-sort-values-plist (plist)~ function
Given a list-valued PLIST, return sorted-list PLIST by order ~leaf-keywords~.

EXAMPLE:
(leaf-sort-values-plist
  '(:config (message "a")
    :disabled (t)))
 -> (:disabled (t)
     :config (message "a"))

**** ~leaf-pcocess-keywords (name plist)~ function
Process keywords for NAME.
The KEY and VALUE are taken from the PLIST and pass to the handler.

The handler is named leaf-handler/KEY.

*** Adding custom keyword
~leaf.el~ can easily be expanded by adding keywords.

Actually, it is realized by two steps of adding keyword and adding handler.

Example:
#+BEGIN_SRC emacs-lisp
  (cort-deftest leaf-test/:simple-keyword-add
    (match-expansion
     (leaf foo
       :require h s :message-post-require "foo!" :config (setq bar 'baz))
     '(progn
        (require 'h)
        (require 's)
        (message "foo!")
        (setq bar 'baz))))

  (cort-deftest leaf-test/:simple-keyword-add-2
    (match-expansion
     (leaf foo
       :require h s
       :message-post-require "foo!"
       :config (setq bar 'baz)
       :message-post-require "post!"
       :message-pre-require "pre")
     '(progn
        (message "pre")
        (require 'h)
        (require 's)
        (message "foo!")
        (message "post!")
        (setq bar 'baz))))

  (cort-deftest leaf-test/:simple-keyword-list-add
    (match-expansion
     (leaf foo
       :require h s
       :tmp-pre (message "start tmp")
       :tmp-post (setq foo 'bar)
       :tmp-pre (message "really start tmp!"))
     '(progn
        (require 'h)
        (require 's)
        (message "start tmp")
        (message "really start tmp!")
        (setq foo 'bar))))
#+END_SRC

**** Add leaf keyword
The keyword has an appropriate place in ~leaf-keywords~.

Because the keywords are sorted in order of ~leaf-keywords~,
and they are processed and expanded in that order.

You can use these functions to add keyword
- ~leaf-add-keyword-before (target belm)~
- ~leaf-add-keyword-after (target aelm)~

If you message before ~require~, you should use
~(leaf-add-keyword-before :message-pre-require :require)~.

Or if you message after ~require~, you should use
~(leaf-add-keyword-after :message-post-require :require)~.

**** Define leaf handler
Then, you should define a handler for new keyword(s) each.

NOTE: Since VALUE is a list, be careful when implementing a handler.
#+BEGIN_SRC emacs-lisp
  (defun leaf-handler/:message-pre-require (name value rest)
    "process :message-pre-require."
    (let ((body (leaf-process-keywords name rest)))
      `(,@(mapcar (lambda (x) `(message ,x)) value) ,@body)))

  (defun leaf-handler/:message-post-require (name value rest)
    "process :message-post-require."
    (let ((body (leaf-process-keywords name rest)))
      `(,@(mapcar (lambda (x) `(message ,x)) value) ,@body)))
#+END_SRC

*** Why We support Emacs-22?
Bundling Emacs-22.1 on macOS 10.13 (High Sierra), we support this.

** Migration
*** leaf v1.0 to v2.0
**** Change not to ~require~ by default
In order to realize the philosophy of "Leaf of setting",
we changed it so as not to ~require~ by default.

If you want to request explicitly use the ~:require t~ flag.
#+begin_src emacs-lisp
  ;; behavior of leaf v2.0
  (leaf foo)
  => (progn)

  (leaf foo :require t)
  => (progn
       (require 'foo))

  ;; behavior of leaf v1.0
  (leaf foo)
  => (progn
       (require 'foo))

  (leaf foo :require t)
  => (progn
       (require 'foo))
#+end_src

** License
#+begin_example
  Affero General Public License Version 3 (AGPLv3)
  Copyright (c) Naoya Yamashita - https://conao3.com
  https://github.com/conao3/orglyth.el/blob/master/LICENSE
#+end_example

** Author
- Naoya Yamashita ([[https://github.com/conao3][conao3]])

** Contributors
- Kzflute ([[https://github.com/Kzflute][Kzflute]])
- KeenS ([[https://github.com/KeenS][κeen]])

** Special Thanks
Advice and comments given by [[http://emacs-jp.github.io/][Emacs-JP]]'s forum member has been a great help
in developing ~leaf.el~.

Thank you very much!!
